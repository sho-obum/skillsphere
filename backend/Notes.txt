SkillSphere — Backend Mini Doc

SkillSphere is a skill-sharing backend (Node.js + Express + MySQL) where providers list skills and customers book time slots. It demonstrates clean REST, JWT auth, role/ownership checks, time-slot overlap logic, and production hygiene (validation, pagination, error handling).

2) Architecture (layers)
Express API → routes → controllers → db (mysql2 pool)

Middleware → JSON parser, auth (JWT), validation, error handler

Auth → bcrypt passwords, Access/Refresh tokens, refresh allowlist table

Modules → Users, Skills, Bookings

External → (next) S3 for images, (next) Docker + AWS EC2 for deploy

3) Data Model (MySQL)
users: id, name, email (unique), password_hash, role [customer|provider|admin], created_at

skills: id, user_id (provider FK), title, description, price, image_url?, created_at

bookings:
id, skill_id (FK), customer_id (FK), provider_id (FK, denormalized), start_time, duration_mins, price_snapshot, status [PENDING|CONFIRMED|CANCELLED|COMPLETED], notes, created_at
Indexes: (provider_id, start_time), (customer_id, start_time)

4) Auth model
Signup → bcrypt hash store

Login → Access Token (15m) + Refresh Token (7d)

Refresh → verify RT (DB allowlist), issue new AT

Logout → delete RT from allowlist

Guard → requireAuth reads Authorization: Bearer <AT> → req.user = { id, role }

AuthZ → ownerOrAdmin checks on skill/booking actions; optional requireRole('provider') for creating skills

5) Key Concepts (interview bullets)
Validation ⇒ 400, Permissions ⇒ 403, Not found ⇒ 404, Overlap ⇒ 409, Server bug ⇒ 500

Pagination: limit/offset with max cap, return { data, limit, offset, has_more }

Time: store & compare in UTC ISO; overlap rule:
[reqStart, reqEnd) overlaps [exStart, exEnd) iff
reqStart < exEnd AND exStart < reqEnd

Security: helmet, cors (allowlist), rate-limit on auth, never log secrets

6) REST Endpoints (contracts)
Auth
POST /api/auth/signup → {name,email,password,role?} → 201 user

POST /api/auth/login → {email,password} → 200 { access_token, user }

POST /api/auth/refresh → { refresh_token } → 200 { access_token }

POST /api/auth/logout → { refresh_token } → 200

Users (sample)
GET /api/users (demo)

(Auth version would add profile, etc.)

Skills
GET /api/skills?limit&offset&q?&provider_id? → { data, limit, offset, has_more }

GET /api/skills/:id → single with owner_name

POST /api/skills (auth; provider) → { title, description?, price? } → 201

PUT /api/skills/:id (auth; owner/admin) → partial update → 200

DELETE /api/skills/:id (auth; owner/admin) → 200

Bookings
POST /api/bookings (auth; customer) → { skill_id, start_time(UTC ISO), duration_mins, notes? } → 201 PENDING

GET /api/bookings/me?role=customer|provider&status?&limit?&offset? → list mine

GET /api/bookings/:id (owner/admin) → details

POST /api/bookings/:id/confirm (provider/admin) → 200 CONFIRMED (re-checks overlap)

POST /api/bookings/:id/cancel (customer/provider/admin) → 200 CANCELLED

POST /api/bookings/:id/complete (provider/admin) → 200 COMPLETED

7) Validation rules (express-validator)
Auth: email format, password ≥ 8

Skills: title 2–120, price ≥ 0

Bookings: ISO start_time in future, duration_mins 30–180

On fail: 400 { error: "Validation failed", details: [...] }

8) Error handling (uniform)
404 fallback: { error: "Route not found" }

Central error handler logs and returns 500 { error: "Something went wrong" }

Known cases mapped to proper 4xx in controllers/middleware

9) ThunderClient test script (happy path)
Login (provider) → get PROVIDER_TOKEN

POST /api/skills (provider) → create skill, note SKILL_ID

Login (customer) → get CUSTOMER_TOKEN

POST /api/bookings (customer) with { skill_id: SKILL_ID, start_time: "YYYY-MM-DDTHH:mm:ssZ", duration_mins: 60 } → 201 PENDING with BOOKING_ID

POST /api/bookings/{BOOKING_ID}/confirm (provider) → 200

**GET /api/bookings/{BOOKING_ID}** (either owner) → status CONFIRMED`

POST /api/bookings/{BOOKING_ID}/complete (provider) → 200

Overlap check: create another overlapping booking & try confirm → 409

10) Known decisions (why)
Denormalized provider_id in bookings for fast permission/overlap checks

Access/Refresh model for stateless APIs; RT allowlist for logout

UTC everywhere to avoid timezone bugs in overlap logic
